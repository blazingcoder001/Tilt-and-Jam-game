package puzzles.common.solver;

import puzzles.jam.model.JamConfig;
import puzzles.jam.model.JamModel;

import java.io.FileNotFoundException;
import java.util.*;

/**
 * A generic solver class that can solve any breadth-first search style puzzle, provided
 * a configuration class has been written which can provide whether it is a solution, and
 * a list of its neighbors.
 *
 * @author Ryan Webb
 */
public class Solver {
    /**
     * Solves a starting configuration using breadth-first search.
     * @param startConfig The starting puzzle configuration.
     * @return A solution object containing interesting statistics
     */
    public static Solution solve(Configuration startConfig) throws FileNotFoundException {
        // prime the queue with the starting node
        List<Configuration> queue = new LinkedList<>();
        queue.add(startConfig);

        // construct predecessors
        Map<Configuration, Configuration> predecessors = new HashMap<>();
        // add start node
        predecessors.put(startConfig, startConfig);

        Configuration finishConfig = null;
        int numConfigs = 1;
        // loop until either the finish node is found,
        // or the queue is empty (no path)
        while (!queue.isEmpty()) {
            // process next node at front of queue
            Configuration current = queue.remove(0);
            /*
            Changes below
             */

            if (current.isSolution()) {
                finishConfig = current;
                break;
            }
            // loop over all neighbors of current
//            if(current!=null)
            for (Configuration nbr : current.getNeighbors()) {

                numConfigs++;
                // process unvisited neighbors
                if (predecessors.containsKey(nbr)) continue; {
                predecessors.put(nbr, current);
                queue.add(nbr);
                }
            }
        }
        List<Configuration> path = new ArrayList<>();
        if (finishConfig != null) {
            path = constructPath(predecessors, startConfig, finishConfig);
        }

        return new Solution(numConfigs, predecessors.size(), path);
    }

    /**
     * Uses the predecessors map to construct an array representing the shortest path generated by the solver.
     * @param predecessors The map of predecessors
     * @param startConfig The starting configuration
     * @param finishConfig The finishing configuration (the solution/goal)
     * @return Path from start to finish as a List.
     */
    private static List<Configuration> constructPath(Map<Configuration, Configuration> predecessors,
                                                   Configuration startConfig, Configuration finishConfig) {
        List<Configuration> path = new LinkedList<>();
        if(predecessors.containsKey(finishConfig)) {
            Configuration currConfig = finishConfig;
            while (currConfig != startConfig) {
                path.add(0, currConfig);
                currConfig = predecessors.get(currConfig);
            }
            path.add(0, startConfig);
        }
        return path;
    }
}
